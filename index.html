<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Truss Drawer â€” Click & Drag</title>
<style>
  body { font-family:sans-serif; text-align:center; background:#fafafa; margin:0; }
  #toolbar { margin:10px; }
  #canvas-wrapper { display:flex; justify-content:center; }
  svg { background:white; border:1px solid #ccc; cursor:crosshair; }
  button { margin:0 5px; padding:6px 12px; }
</style>
</head>
<body>
<h2>Interactive Truss Drawer (Click & Drag with Grid Snap)</h2>
<div id="toolbar">
  <button id="clear">Clear</button>
</div>
<div id="canvas-wrapper">
  <svg id="canvas" width="800" height="500"></svg>
</div>

<script>
const canvas = document.getElementById("canvas");
const GRID = 20;
let nodes = [];
let members = [];
let drawing = false;
let startNode = null;
let tempLine = null;

// --- grid setup ---
function drawGrid() {
  const w = canvas.clientWidth, h = canvas.clientHeight;
  for (let x = 0; x <= w; x += GRID) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", x); line.setAttribute("y1", 0);
    line.setAttribute("x2", x); line.setAttribute("y2", h);
    line.setAttribute("stroke", "#eee");
    canvas.appendChild(line);
  }
  for (let y = 0; y <= h; y += GRID) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", 0); line.setAttribute("y1", y);
    line.setAttribute("x2", w); line.setAttribute("y2", y);
    line.setAttribute("stroke", "#eee");
    canvas.appendChild(line);
  }
}
drawGrid();
const gridCount = canvas.childNodes.length;

// --- snap helper ---
function snap(v) { return Math.round(v / GRID) * GRID; }

// --- draw everything except grid ---
function redraw() {
  while (canvas.childNodes.length > gridCount)
    canvas.removeChild(canvas.lastChild);

  // draw members
  for (const m of members) {
    const n1 = nodes[m.n1], n2 = nodes[m.n2];
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", n1.x); line.setAttribute("y1", n1.y);
    line.setAttribute("x2", n2.x); line.setAttribute("y2", n2.y);
    line.setAttribute("stroke", "#000"); line.setAttribute("stroke-width", "2");
    canvas.appendChild(line);
  }

  // draw nodes
  for (const n of nodes) {
    const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    c.setAttribute("cx", n.x); c.setAttribute("cy", n.y);
    c.setAttribute("r", 4); c.setAttribute("fill", "#d00");
    canvas.appendChild(c);
  }
}

// --- event handlers ---
canvas.addEventListener("mousedown", e => {
  const x = snap(e.offsetX), y = snap(e.offsetY);
  startNode = getOrCreateNode(x, y);
  drawing = true;

  // show temporary line
  tempLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
  tempLine.setAttribute("x1", x); tempLine.setAttribute("y1", y);
  tempLine.setAttribute("x2", x); tempLine.setAttribute("y2", y);
  tempLine.setAttribute("stroke", "#00f");
  tempLine.setAttribute("stroke-width", "1.5");
  canvas.appendChild(tempLine);
});

canvas.addEventListener("mousemove", e => {
  if (!drawing || !tempLine) return;
  tempLine.setAttribute("x2", snap(e.offsetX));
  tempLine.setAttribute("y2", snap(e.offsetY));
});

canvas.addEventListener("mouseup", e => {
  if (!drawing) return;
  drawing = false;
  const endNode = getOrCreateNode(snap(e.offsetX), snap(e.offsetY));
  if (startNode && endNode && startNode.id !== endNode.id) {
    members.push({ n1:startNode.id, n2:endNode.id });
  }
  if (tempLine) canvas.removeChild(tempLine);
  tempLine = null;
  redraw();
});

// --- utility ---
function getOrCreateNode(x, y) {
  let existing = nodes.find(n => n.x===x && n.y===y);
  if (existing) return existing;
  const node = { id:nodes.length, x, y };
  nodes.push(node);
  return node;
}

// --- clear ---
document.getElementById("clear").onclick = () => {
  nodes = [];
  members = [];
  redraw();
};

redraw();
</script>
</body>
</html>
