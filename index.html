<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Truss Drawer â€” Grid + Drag Lines</title>
  <style>
    body { font-family:sans-serif; text-align:center; background:#fafafa; margin:0; }
    #toolbar { margin:10px; }
    #canvas-wrapper { display:flex; justify-content:center; }
    svg { background:white; border:1px solid #ccc; cursor:crosshair; }
    button { margin:0 5px; padding:6px 12px; }
  </style>
</head>
<body>
<h2>Interactive Truss Drawer (Grid Snap + Drag to Draw)</h2>

<div id="toolbar">
  <button id="clear">Clear</button>
</div>

<div id="canvas-wrapper">
  <svg id="canvas" width="800" height="500"></svg>
</div>

<script>
const canvas = document.getElementById("canvas");
const GRID = 20;

let nodes = [];        // {id,x,y}
let members = [];      // {n1,n2}
let drawing = false;
let startNode = null;
let tempLine = null;

// --- helpers ---
function snap(v) {
  return Math.round(v / GRID) * GRID;
}

function svgCoords(evt) {
  // works reliably even on GitHub Pages / scrolled pages
  const rect = canvas.getBoundingClientRect();
  return {
    x: evt.clientX - rect.left,
    y: evt.clientY - rect.top
  };
}

function getOrCreateNode(x, y) {
  let n = nodes.find(p => p.x === x && p.y === y);
  if (n) return n;
  n = { id: nodes.length, x, y };
  nodes.push(n);
  return n;
}

// --- grid ---
function drawGrid() {
  const w = canvas.viewBox.baseVal.width || canvas.clientWidth;
  const h = canvas.viewBox.baseVal.height || canvas.clientHeight;

  for (let x = 0; x <= w; x += GRID) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", x); line.setAttribute("y1", 0);
    line.setAttribute("x2", x); line.setAttribute("y2", h);
    line.setAttribute("stroke", "#eee");
    canvas.appendChild(line);
  }
  for (let y = 0; y <= h; y += GRID) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", 0); line.setAttribute("y1", y);
    line.setAttribute("x2", w); line.setAttribute("y2", y);
    line.setAttribute("stroke", "#eee");
    canvas.appendChild(line);
  }
}

// set fixed viewBox so coords behave
canvas.setAttribute("viewBox", `0 0 ${canvas.getAttribute("width")} ${canvas.getAttribute("height")}`);
drawGrid();
const gridCount = canvas.childNodes.length;

// --- redraw members + nodes (keep grid) ---
function redraw() {
  while (canvas.childNodes.length > gridCount)
    canvas.removeChild(canvas.lastChild);

  // members
  for (const m of members) {
    const n1 = nodes[m.n1], n2 = nodes[m.n2];
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", n1.x); line.setAttribute("y1", n1.y);
    line.setAttribute("x2", n2.x); line.setAttribute("y2", n2.y);
    line.setAttribute("stroke", "#000");
    line.setAttribute("stroke-width", "2");
    canvas.appendChild(line);
  }

  // nodes
  for (const n of nodes) {
    const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    c.setAttribute("cx", n.x); c.setAttribute("cy", n.y);
    c.setAttribute("r", 4);
    c.setAttribute("fill", "#d00");
    canvas.appendChild(c);
  }
}

// --- mouse events ---
canvas.addEventListener("mousedown", (evt) => {
  const {x, y} = svgCoords(evt);
  const sx = snap(x), sy = snap(y);

  startNode = getOrCreateNode(sx, sy);
  drawing = true;

  tempLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
  tempLine.setAttribute("x1", sx);
  tempLine.setAttribute("y1", sy);
  tempLine.setAttribute("x2", sx);
  tempLine.setAttribute("y2", sy);
  tempLine.setAttribute("stroke", "#00f");
  tempLine.setAttribute("stroke-width", "1.5");
  tempLine.setAttribute("stroke-dasharray", "4 3");
  canvas.appendChild(tempLine);
});

canvas.addEventListener("mousemove", (evt) => {
  if (!drawing || !tempLine) return;
  const {x, y} = svgCoords(evt);
  tempLine.setAttribute("x2", snap(x));
  tempLine.setAttribute("y2", snap(y));
});

canvas.addEventListener("mouseup", (evt) => {
  if (!drawing) return;
  drawing = false;

  const {x, y} = svgCoords(evt);
  const ex = snap(x), ey = snap(y);
  const endNode = getOrCreateNode(ex, ey);

  if (tempLine) {
    canvas.removeChild(tempLine);
    tempLine = null;
  }

  if (startNode && endNode && startNode.id !== endNode.id) {
    const exists = members.some(m =>
      (m.n1 === startNode.id && m.n2 === endNode.id) ||
      (m.n1 === endNode.id && m.n2 === startNode.id)
    );
    if (!exists) {
      members.push({ n1: startNode.id, n2: endNode.id });
    }
  }

  startNode = null;
  redraw();
});

// Clear
document.getElementById("clear").onclick = () => {
  nodes = [];
  members = [];
  startNode = null;
  tempLine = null;
  redraw();
};

redraw();
</script>
</body>
</html>
